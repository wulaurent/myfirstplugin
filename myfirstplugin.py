# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PluginScript
                                 A QGIS plugin
 Mon premier plugin QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-02-06
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Laurent WU
        email                : laurent.wu@ensg.eu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

from PyQt5.QtWidgets import QMessageBox

from qgis.core import QgsProject, QgsVectorLayer, QgsPointXY, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsGeometry, QgsFeatureRequest, QgsFeature, QgsField
from qgis.gui import QgsMapToolEmitPoint
from qgis.PyQt.QtGui import QColor

import requests

from .resources import *
from .myfirstplugin_dialog import PluginScriptDialog
import os.path


class PluginScript:

    def __init__(self, iface):

        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(
            self.plugin_dir, "i18n", "PluginScript_{}.qm".format(locale)
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        self.actions = []
        self.menu = self.tr("&MyFirstPlugin")

        self.first_start = None

        # gestion du clic sur la carte
        self.canvas = iface.mapCanvas()
        self.map_tool = QgsMapToolEmitPoint(self.canvas)
        self.map_tool.canvasClicked.connect(self.on_canvas_click)
        
    def tr(self, message):
        return QCoreApplication.translate("PluginScript", message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):

        icon_path = ":/plugins/myfirstplugin/icon.png"
        self.add_action(
            icon_path,
            text=self.tr(""),
            callback=self.run,
            parent=self.iface.mainWindow(),
        )

        self.first_start = True

    def unload(self):
        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&MyFirstPlugin"), action)
            self.iface.removeToolBarIcon(action)

    def run(self):

        if self.first_start == True:
            self.first_start = False
            self.dlg = PluginScriptDialog()

        self.list_layers()
        self.dlg.show()

        # active le clique sur la carte
        self.canvas.setMapTool(self.map_tool)
        result = self.dlg.exec_()

        if result:
            pass

        self.remove_buffer_layer()
        
        # désactive le clique sur la carte lorsque le plugin est fermé
        self.canvas.unsetMapTool(self.map_tool)

    
    # fonction utilitaire de transformation de systeme de projection
    def transform_coordinates(self, point, source_crs, target_crs):
        transform = QgsCoordinateTransform(source_crs, target_crs, QgsProject.instance())
        return transform.transform(point)

    # liste les couches ponctuels dans le projet courant
    def list_layers(self):

        # clear le contenu de mon widget combobox avant chaque lancement de la fonction
        self.dlg.combobox_layers.clear()

        # récupère les couches du projet courant
        layers = QgsProject.instance().mapLayers().values()

        if not layers:
            QMessageBox.warning(self.dlg, "Attention", "Aucune couche trouvée dans le projet.")
            return

        # ensemble pour stocker les noms uniques des couches
        unique_layer_names = set()

        for layer in layers:
            # filtre uniquement les couches vectorielles
            if layer.type() == QgsVectorLayer.VectorLayer:

                # filtre uniquement les couches ponctuelles
                if layer.wkbType() == 1:
                    layer_name = layer.name()

                    # filtre les uniques names
                    if layer_name not in unique_layer_names:
                        self.dlg.combobox_layers.addItem(layer_name)
                        unique_layer_names.add(layer_name)

    # clique sur la carte pour obtenir les coordonnées correspondantes au point cliqué
    def on_canvas_click(self, point):
        
        try:
            # récupère les coordonnées du point cliqué dans le système de coordonnées du canvas
            map_point = QgsPointXY(point.x(), point.y())

            # transforme des coordonnées (EPSG:4326)
            map_crs = self.canvas.mapSettings().destinationCrs()
            wgs_crs = QgsCoordinateReferenceSystem("EPSG:4326")
            point_wgs = self.transform_coordinates(map_point, map_crs, wgs_crs)

            # recup la distance du buffer depuis l'interface utilisateur
            distance_meters = self.dlg.meters_label.text()

            if not distance_meters.isdigit():
                QMessageBox.warning(self.dlg, "Erreur", "Veuillez entrer une distance valide en mètres.")
                return

            # creation du point et du tampon
            point_geometry = QgsGeometry.fromPointXY(map_point)
            buffer_geometry = point_geometry.buffer(float(distance_meters), 10)

            # extract du long et lat
            lon = round(point_wgs.x(), 5)
            lat = round(point_wgs.y(), 5)

            # affiche les coordonnées dans l'interface utilisateur
            self.dlg.longitude_point.setText(str(lon))
            self.dlg.latitude_point.setText(str(lat))

            # effecue le géocodage inverse
            self.reverse_geocoding(lon, lat)

            # recup le nom de la couche sélectionnée
            select_layername = self.dlg.combobox_layers.currentText()

            if not select_layername:
                QMessageBox.warning(self.dlg, "Erreur", "Aucune couche sélectionnée.")
                return
            
            self.count_objects_nearest(select_layername, buffer_geometry)
            self.display_buffer_zone(buffer_geometry)
            self.canvas.setMapTool(self.map_tool)

        except Exception as e:
            QMessageBox.critical(self.dlg, "Erreur", f"Une erreur est survenue lors du clic sur la carte : {e}")



    # clique sur la carte et obtiens l’adresse BAN la plus proche du point cliqué
    def reverse_geocoding(self, lon, lat):
        url = f'https://data.geopf.fr/geocodage/reverse?lat={lat}&lon={lon}&limit=1&type=housenumber'

        try:
            # requetage sur l'api ban en type get
            response = requests.get(url)

            # valide la requete
            if response.status_code == 200:

                # extrait les data en format json
                data = response.json()

                # extraction des données de la requete
                if data.get('features'):
                    name_voie = data['features'][0]['properties'].get("name")
                    citycode = data['features'][0]['properties'].get("citycode")
                    city = data['features'][0]['properties'].get("city")

                    address = f'{name_voie}, {citycode} {city}'

                    # ajout la valeur au widget
                    self.dlg.address_edit.setText(str(address))

                else :
                    self.dlg.address_edit.setText(f'Adresse introuvable')

        except Exception as e:
            self.dlg.address_edit.setText(f'Erreur : {e}')

    # compte les objets dans le buffer
    def count_objects_nearest(self, layer_name, buffer_geom):
        try:
            # récupère la couche du combobox
            layer = QgsProject.instance().mapLayersByName(layer_name)[0]

            if not layer:
                print(f"La couche {layer_name} n'existe pas.")
                return

            layer_crs = layer.crs()

            map_crs = self.canvas.mapSettings().destinationCrs()

            # transforme la géométrie du buffer dans le CRS de la couche
            transform = QgsCoordinateTransform(map_crs, layer_crs, QgsProject.instance())
            buffer_geom.transform(transform)

            # compte le nb de feature à partir d'une jointure spatiale 
            count = 0
            for feature in layer.getFeatures():
                feature_geom = feature.geometry()
                if feature_geom.intersects(buffer_geom):
                    count += 1

            self.dlg.object_label.setText(str(count))
        
        except Exception as e:
            QMessageBox.critical(self.dlg, "Erreur", f"erreur lors du comptage des objets : {e}")



    # créer une zone tampon autour du point cliqué sur la carte
    def display_buffer_zone(self, buffer_geometry):
        try:
            layer_name = 'buffers'
            
            # supprime les mêmes layer ayant le même nom
            existing_layers = QgsProject.instance().mapLayersByName(layer_name)
            for layer in existing_layers:
                QgsProject.instance().removeMapLayer(layer)

            # vérifie si mon buffer est vide
            if buffer_geometry.isEmpty():
                print('La géométrie est vide')
                return
            
            # conversion du buffer dans le bon système de proj et crée la zone tampon temporaire 
            project_crs = self.canvas.mapSettings().destinationCrs()
            wgs_crs = QgsCoordinateReferenceSystem("EPSG:4326")
            buffer_geometry.transform(QgsCoordinateTransform(wgs_crs, project_crs, QgsProject.instance()))
            buffer_layer = QgsVectorLayer(f"Polygon?crs={project_crs.authid()}", layer_name, "memory")

            # construction des data dans la mémoire
            provider = buffer_layer.dataProvider()

            # active l'édition de la couche tampon
            buffer_layer.startEditing()

            # crée l'entité avec la géométrie du buffer
            feature = QgsFeature()
            feature.setGeometry(buffer_geometry)
            provider.addFeatures([feature])

            # sauvegarde les changements
            buffer_layer.commitChanges()

            # applique un style de symbo à la zone tampon
            symbol = buffer_layer.renderer().symbol()
            symbol_layer = symbol.symbolLayer(0)

            if symbol_layer:

                # contour noir
                symbol_layer.setStrokeColor(QColor("#000000"))

                # épaisseur du contour
                symbol_layer.setStrokeWidth(0.3)

                # remplissage transparent
                symbol_layer.setFillColor(QColor(0, 0, 0, 0))

            # redessinement du buffer avec les nouvelles symbo
            buffer_layer.triggerRepaint()
            
            # ajoute la couche au projet courant
            QgsProject.instance().addMapLayer(buffer_layer)

            # refresh la map pour faire apparaitre la nouvelle couche
            self.canvas.setLayers(self.canvas.layers())

        except Exception as e:
            QMessageBox.critical(None, "Erreur", f'Une erreur est survenue : {e}')
    
    # supprime ma couche tampon si elle existe
    def remove_buffer_layer(self):

        # selectionne ma zone tampon à partir de son nom
        layers = QgsProject.instance().mapLayersByName('buffers')
        if layers:
            # supprime ma couche s'il mon buffer existe
            QgsProject.instance().removeMapLayer(layers[0].id())

        # refresh la carte
        self.canvas.refresh()
