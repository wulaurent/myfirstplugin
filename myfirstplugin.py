# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PluginScript
                                 A QGIS plugin
 Mon premier plugin QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-02-06
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Laurent WU
        email                : laurent.wu@ensg.eu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

from PyQt5.QtWidgets import QMessageBox

from qgis.core import QgsProject, QgsVectorLayer, QgsPointXY, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsGeometry, QgsFeatureRequest, QgsFeature, QgsField
from qgis.gui import QgsMapToolEmitPoint
from qgis.PyQt.QtGui import QColor

import requests

from .resources import *
from .myfirstplugin_dialog import PluginScriptDialog
import os.path


class PluginScript:

    def __init__(self, iface):

        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(
            self.plugin_dir, "i18n", "PluginScript_{}.qm".format(locale)
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        self.actions = []
        self.menu = self.tr("&MyFirstPlugin")

        self.first_start = None

        # gestion du clic sur la carte
        self.canvas = iface.mapCanvas()
        self.map_tool = QgsMapToolEmitPoint(self.canvas)
        self.map_tool.canvasClicked.connect(self.on_canvas_click)
        self.canvas.setMapTool(self.map_tool)

    def tr(self, message):
        return QCoreApplication.translate("PluginScript", message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):

        icon_path = ":/plugins/myfirstplugin/icon.png"
        self.add_action(
            icon_path,
            text=self.tr(""),
            callback=self.run,
            parent=self.iface.mainWindow(),
        )

        self.first_start = True

    def unload(self):
        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&MyFirstPlugin"), action)
            self.iface.removeToolBarIcon(action)

    def run(self):

        if self.first_start == True:
            self.first_start = False
            self.dlg = PluginScriptDialog()

        self.list_layers()
        self.dlg.show()
        result = self.dlg.exec_()
        if result:
            pass

    
    # fonction utilitaire de transformation de systeme de projection
    def transform_coordinates(self, point, source_crs, target_crs):
        transform = QgsCoordinateTransform(source_crs, target_crs, QgsProject.instance())
        return transform.transform(point)

    # liste les couches ponctuels dans le projet courant
    def list_layers(self):

        # clear le contenue de mon widget comboxbox avant chaque lancement de la fonction
        self.dlg.combobox_layers.clear()

        # récupère les noms des couches du projet courant
        layers_name = QgsProject.instance().mapLayers().values()

        for layer in layers_name:
            # filtre uniquement les couches vectorielles
            if layer.type() == QgsVectorLayer.VectorLayer:

                # filtre uniquement les couches poncutelles
                if layer.wkbType() == 1:
                    self.dlg.combobox_layers.addItem(layer.name())

    # clique sur la carte pour obtenir les coordonnées correspondantes au point cliqué
    def on_canvas_click(self, point):
        # récupère les coordonnées du point cliqué dans le système de coordonnées du canvas
        map_point = QgsPointXY(point.x(), point.y())

        # transforme des coordonnées (EPSG:4326)
        map_crs = self.canvas.mapSettings().destinationCrs()
        wgs_crs = QgsCoordinateReferenceSystem("EPSG:4326")
        point_wgs = self.transform_coordinates(map_point, map_crs, wgs_crs)

        # recup la distance du buffer depuis l'interface utilisateur
        distance_meters = self.dlg.meters_label.text()

        if not distance_meters.isdigit():
            QMessageBox.warning(self.dlg, "Erreur", "Veuillez entrer une distance valide en mètres.")
            return

        # creation du point et du tampon
        point_geometry = QgsGeometry.fromPointXY(map_point)
        buffer_geometry = point_geometry.buffer(float(distance_meters), 10)

        # extract du long et lat
        lon = round(point_wgs.x(), 5)
        lat = round(point_wgs.y(), 5)
        print(f'lon : {lon}, lat : {lat}')

        # affiche les coordonnées dans l'interface utilisateur
        self.dlg.longitude_point.setText(str(lon))
        self.dlg.latitude_point.setText(str(lat))

        # effecue le géocodage inverse
        self.reverse_geocoding(lon, lat)

        # recup le nom de la couche sélectionnée
        select_layername = self.dlg.combobox_layers.currentText()

        if select_layername:
            self.count_objects_nearest(select_layername, buffer_geometry)

        self.display_buffer_zone(buffer_geometry)
        self.canvas.setMapTool(self.map_tool)



    # clique sur la carte et obtiens l’adresse BAN la plus proche du point cliqué
    def reverse_geocoding(self, lon, lat):
        url = f'https://data.geopf.fr/geocodage/reverse?lat={lat}&lon={lon}&limit=1&type=housenumber'

        try:
            # requetage sur l'api ban en type get
            response = requests.get(url)

            # valide la requete
            if response.status_code == 200:

                # extrait les data en format json
                data = response.json()

                # extraction des données de la requete
                if data.get('features'):
                    name_voie = data['features'][0]['properties'].get("name")
                    citycode = data['features'][0]['properties'].get("citycode")
                    city = data['features'][0]['properties'].get("city")

                    address = f'{name_voie}, {citycode} {city}'

                    # ajout la valeur au widget
                    self.dlg.address_edit.setText(str(address))

                else :
                    self.dlg.address_edit.setText(f'Adresse introuvable')

        except Exception as e:
            self.dlg.address_edit.setText(f'Erreur : {e}')

    # compte les objets dans le buffer
    def count_objects_nearest(self, layer_name, buffer_geom):

        # récupère la couche du combobox
        layer = QgsProject.instance().mapLayersByName(layer_name)[0]

        if not layer:
            print(f"La couche {layer_name} n'existe pas.")
            return

        layer_crs = layer.crs()

        map_crs = self.canvas.mapSettings().destinationCrs()

        # transforme la géométrie du buffer dans le CRS de la couche
        transform = QgsCoordinateTransform(map_crs, layer_crs, QgsProject.instance())
        buffer_geom.transform(transform)

        # compte le nb de feature à partir d'une jointure spatiale 
        count = 0
        for feature in layer.getFeatures():
            feature_geom = feature.geometry()
            if feature_geom.intersects(buffer_geom):
                count += 1

        self.dlg.object_label.setText(str(count))


    # créer une zone tampon autour du point cliqué sur la carte
    def display_buffer_zone(self, buffer_geometry):
        try:
            layer_name = 'buffers'
            
            # supprime les mêmes layer ayant le même nom
            existing_layers = QgsProject.instance().mapLayersByName(layer_name)
            for layer in existing_layers:
                QgsProject.instance().removeMapLayer(layer)

            # vérifie si mon buffer est vide
            if buffer_geometry.isEmpty():
                print('La géométrie est vide')
                return
            
            # conversion du buffer dans le bon système de proj et crée la zone tampon temporaire 
            project_crs = self.canvas.mapSettings().destinationCrs()
            wgs_crs = QgsCoordinateReferenceSystem("EPSG:4326")
            buffer_geometry.transform(QgsCoordinateTransform(wgs_crs, project_crs, QgsProject.instance()))
            buffer_layer = QgsVectorLayer(f"Polygon?crs={project_crs.authid()}", layer_name, "memory")

            # construction des data dans la mémoire
            provider = buffer_layer.dataProvider()

            # active l'édition de la couche tampon
            buffer_layer.startEditing()

            # crée l'entité avec la géométrie du buffer
            feature = QgsFeature()
            feature.setGeometry(buffer_geometry)
            provider.addFeatures([feature])

            # sauvegarde les changements
            buffer_layer.commitChanges()

            # applique un style de symbo à la zone tampon
            symbol = buffer_layer.renderer().symbol()
            symbol_layer = symbol.symbolLayer(0)

            if symbol_layer:

                # contour noir
                symbol_layer.setStrokeColor(QColor("#000000"))

                # épaisseur du contour
                symbol_layer.setStrokeWidth(0.3)

                # remplissage transparent
                symbol_layer.setFillColor(QColor(0, 0, 0, 0))

            # redessinement du buffer avec les nouvelles symbo
            buffer_layer.triggerRepaint()
            
            # ajoute la couche au projet courant
            QgsProject.instance().addMapLayer(buffer_layer)

            # refresh la map pour faire apparaitre la nouvelle couche
            self.canvas.setLayers(self.canvas.layers())

        except Exception as e:
            QMessageBox.critical(None, "Erreur", f'Une erreur est survenue : {e}')
